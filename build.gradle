buildscript {
    repositories {
        maven { url 'https://plugins.gradle.org/m2/' }
    }
    dependencies {
        classpath group: 'com.netflix.nebula', name: 'nebula-dependency-recommender', version: '4.2.0'
        classpath group: 'com.netflix.nebula', name: 'nebula-publishing-plugin', version: '4.2.0'
        classpath group: 'com.jfrog.bintray.gradle', name: 'gradle-bintray-plugin', version: '1.7.3'
        classpath group: 'org.starchartlabs.flare', name: 'flare-operations-plugins', version: '2.0.0'
        classpath group: 'org.starchartlabs.flare', name: 'flare-publishing-plugins', version: '0.3.0'
    }
}

apply plugin: 'groovy'
apply plugin: 'eclipse'
apply plugin: 'jacoco'
apply plugin: 'maven-publish'
apply plugin: 'nebula.dependency-recommender'
apply plugin: 'nebula.maven-resolved-dependencies'
apply plugin: 'nebula.maven-base-publish'
apply plugin: 'nebula.maven-dependencies'
apply plugin: 'com.jfrog.bintray'
apply plugin: 'org.starchartlabs.flare.increase-test-logging'
apply plugin: 'org.starchartlabs.flare.dependency-reporting'
apply plugin: 'org.starchartlabs.flare.published-project'

description = 'Gradle plug-ins to enhance publishing operations such as jar and POM generation'

//Default all projects to a synchronized IDE version number
group = 'org.starchartlabs.flare'

dependencyRecommendations {
        propertiesFile file: file("${rootDir}/dependencies.properties")
}

//Always download sources, to allow debugging, and use Eclipse containers for greater portability
eclipse {
    classpath {
        downloadSources=true
    }
}

//JCenter is the Gradle plug-in standard
repositories {
    jcenter()
}

//Dependency versions managed in $rootDir/dependencies.properties
dependencies {
    compile gradleApi()
    compile localGroovy()
    
    testCompile group: 'org.testng', name: 'testng'
}

//Add LICENSE so it is included in all JARs, fulfilling the "distributions include license" requirement
jar{
    from("${rootDir}"){
        include 'LICENSE'
    }
}

//All projects should provide source code and javadoc, and upload these with any released artifacts
sourcesJar{
    from("${rootDir}"){
        include 'LICENSE'
    }
}

javadocJar{
    from("${rootDir}"){
        include 'LICENSE'
    }
}

//Setup default test behavior, including failure logging
test {
    useTestNG() {
        useDefaultListeners = true
    }
}

jacocoTestReport {
    reports {
        executionData fileTree(project.rootDir.absolutePath).include("**/build/jacoco/*.exec")
        
        sourceSets project.sourceSets.main
        
        xml.enabled true
        csv.enabled false
        html.enabled false
        xml.destination file("${buildDir}/reports/jacoco/report.xml")
    }
}

jacocoTestReport.dependsOn test
check.dependsOn jacocoTestReport

//If not a remote run, publish to local only
if(!project.hasProperty('remoteDeploy')){
    publishing {
        repositories {
            mavenLocal()
        }
    }
}

publishedInfo{
    url = 'https://github.com/Corona-IDE/flare-publishing-plugins'
  
    scm{
      github 'StarChart-Labs', 'flare-publishing-plugins'
    }
  
    licenses{
      mit('repo')
    }
  
    developers{
      github 'romeara', 'Ryan OMeara'
    }
}

bintray {
    user = System.getProperty('bintray_user')
    key = System.getProperty('bintray_key')
    publications = [ 'nebula' ]

    if(!project.hasProperty('remoteDeploy')){
        dryRun = true
    }

    pkg {
        repo = 'flare'
        name = "${project.name}"
        userOrg = 'starchart-labs'
        licenses = ['MIT']
        vcsUrl = 'https://github.com/StarChart-Labs/flare-publishing-plugins.git'

        version {
            name = "${project.version}"
            desc = "${project.name} release ${project.version} final"
            released  = new Date()
            vcsTag = "v${project.version}"

            gpg {
                sign = true
            }
        }
    }
}
